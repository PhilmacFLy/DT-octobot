C166 COMPILER V7.05, SENSORIC                                                              12/05/2013 12:54:49 PAGE 1   


C166 COMPILER V7.05, COMPILATION OF MODULE SENSORIC
OBJECT MODULE PLACED IN .\obj\sensoric.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C166\BIN\C166.EXE sensoric.c MODV2 BROWSE MODV2 DEBUG OBJECT(.\obj\sensoric.o
                    -bj) 

 stmt lvl     source

*** WARNING C500 IN LINE 1 OF sensoric.c: SERIAL NUMBER EXPIRED

    1         
    2         #include "XE16xREGS.H"
    3         
    4         #include "ADC0.H"
    5         
    6         #include "sensoric.h"
    7         
    8         volatile unsigned int speed_spin = 0;
    9         volatile unsigned int accel_x = 0;
   10         volatile unsigned int accel_y = 0;
   11         volatile unsigned int accel_z = 0;
   12         
   13         void ReadSensorData()
   14         {
   15  1         // read ALL! the ADC channels
   16  1         //13,14,5 for gyro acceleration
   17  1         //7 for spinning sensor
   18  1         //register 0 - channel 5  (Acceleration Z Axix)
   19  1         //register 1 - channel 6  (Acceleration Spinning)
   20  1         //register 2 - channel 7  (unused)
   21  1         //register 3 - channel 13 (Acceleration )
   22  1         //register 4 - channel 14 ()
   23  1         //register 5 - channel 15 (unused)
   24  1         ADC0_vStartSeq0ReqChNum(0, 0, 0, ADC0_ANA_5);
   25  1         ADC0_vStartSeq2ReqChNum(0, 0, 0, ADC0_ANA_13);
   26  1         while(!ADC0_uwResultValid(RESULT_REG_0) && !ADC0_uwResultValid(RESULT_REG_3)); // necessary?
   27  1         ADC0_vStartSeq0ReqChNum(0, 0, 0, ADC0_ANA_6);
   28  1         ADC0_vStartSeq2ReqChNum(0, 0, 0, ADC0_ANA_14);
   29  1         while(!ADC0_uwResultValid(RESULT_REG_1) && !ADC0_uwResultValid(RESULT_REG_4)); // necessary?
   30  1         //ADC0_vStartSeq0ReqChNum(0, 0, 0, ADC0_ANA_7);
   31  1         //ADC0_vStartSeq2ReqChNum(0, 0, 0, ADC0_ANA_15);  
   32  1         //while(!ADC0_uwResultValid(RESULT_REG_2) && !ADC0_uwResultValid(RESULT_REG_5)); // necessary?
   33  1      
   34  1         accel_x = ADC0_uwGetResultData(RESULT_REG_3);
   35  1         accel_y = ADC0_uwGetResultData(RESULT_REG_4);
   36  1         accel_z = ADC0_uwGetResultData(RESULT_REG_0);
   37  1         speed_spin = ADC0_uwGetResultData(RESULT_REG_1);
   38  1      }
   39         
   40         unsigned char ReadAccelValueRaw(unsigned char direction)
   41         {                                                                          
   42  1        if (direction == DIRECTION_X) return ((unsigned char) (accel_x >> 2));
   43  1        if (direction == DIRECTION_Y) return ((unsigned char) (accel_y >> 2));
   44  1        if (direction == DIRECTION_Z) return ((unsigned char) (accel_z >> 2));
   45  1        return 0;
   46  1      }
   47           
   48         unsigned char ReadSpinValueRaw()
   49         {
   50  1        return ((unsigned char) (speed_spin >> 2));
   51  1      } 
   52         
   53         // untested
C166 COMPILER V7.05, SENSORIC                                                              12/05/2013 12:54:49 PAGE 2   

   54         //DIRECTION_X positive value: backward, negative value: forward
   55         //DIRECTION_Y positive value: left, negative value: right
   56         //DIRECTION_Z positive value: down, negative value: up
   57         signed int ReadAccelValue(unsigned char direction)
   58         {
   59  1        unsigned int tmp = 0;
   60  1        signed int x;
   61  1      
   62  1        if (direction == DIRECTION_X) tmp = accel_x;
   63  1        if (direction == DIRECTION_Y) tmp = accel_y;
   64  1        if (direction == DIRECTION_Z) tmp = accel_z;
   65  1      
   66  1        // 0 - 0x3FF / 0 - 1023, voltage is irrelevant because Vs = Vref
   67  1        // 511/512 is middle
   68  1        if (tmp < 512) x = - ( (signed int) (511 - tmp) ); // <= 511 is negative
   69  1        else           x =   ( (signed int) (tmp - 512) ); // >= 512 is positive
   70  1        
   71  1        // at Vs = 3,3V, the sensitivity is about 330mV / g
   72  1        // therefore, -511 to 511 is similar to -5G - +5G
   73  1        return ((x * 1000) / 1022); // return value * 0,01g = X g
   74  1      }
   75         
   76         // untested
   77         // positive value: vorwärts kipping
   78         // negative value: rückwärts kipping
   79         signed int ReadSpinValue()
   80         {
   81  1        unsigned int tmp = speed_spin;
   82  1        signed int x;
   83  1      
   84  1        // 0 - 0x3FF / 0 - 1023, voltage is irrelevant because Vs = Vref
   85  1        // 511/512 is middle
   86  1        if (tmp < 512) x = - ( (signed int) (511 - tmp) ); // <= 511 is negative
   87  1        else           x =   ( (signed int) (tmp - 512) ); // >= 512 is positive
   88  1      
   89  1        // at Vs = 3,3V the sensitivity is about 3,3mV / °/s
   90  1        // therefore, -511 to 511 is similar to -500°/s - +500°/s
   91  1        return (( x * 1000) / 1022); // return value = X°/s
   92  1      }


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         380     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =           8     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          24     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
